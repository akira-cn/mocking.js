const path = require('node:path');
const marked = require('marked');
const {markedHighlight} = require("marked-highlight");
const hljs = require('highlight.js');
const qs = require('qs');

const display = require('./template.js');
const generate = require('./generate.js');

const renderer = new marked.Renderer();

renderer.heading = function(text, level, raw) {
  if(level <= 3) {
    const anchor = 'mockingjay-' + raw.toLowerCase().replace(/[^\w\\u4e00-\\u9fa5]]+/g, '-');
    return `<h${level} id="${anchor}"><a class="anchor" aria-hidden="true" href="#${anchor}"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>${text}</h${level}>\n`;
  } else {
    return `<h${level}>${text}</h${level}>\n`;
  }
};

const options = {
  // langPrefix: 'language-',
  renderer,
  pedantic: false,
  gfm: true,
  breaks: false,
  sanitize: false,
  smartLists: true,
  smartypants: false,
  xhtml: false,
  headerIds: false,
  mangle: false,
};

marked.setOptions(options);
marked.use(markedHighlight({
  langPrefix: 'hljs language-',
  highlight(code, lang) {
    const language = hljs.getLanguage(lang) ? lang : 'plaintext';
    return hljs.highlight(code, { language }).value;
  }
}));

function makeParamsBody(params) {
  const body = {};
  for(let i = 0; i < params.length; i++) {
    const {name, defaultValue} = params[i];
    body[name] = defaultValue;
  }
  const ret = `body: JSON.stringify(${JSON.stringify(body, null, 2)})`.replace(/^/mg, '  ');
  return `\n${ret}`;
}

function makeQuery(params) {
  const body = {};
  for(let i = 0; i < params.length; i++) {
    const {name, defaultValue} = params[i];
    body[name] = defaultValue;
  }
  return `?${qs.stringify(body)}`;
}

module.exports = class Mock {
  #name = 'Demo API';
  #desc = 'API generated by mockingjay.';
  #schemas = {};
  #responseHeaders = {};
  #responses = {};
  #params = {};

  constructor(name, desc) {
    this.#name = name;
    this.#desc = desc;
  }

  info() {
    return `# ${this.#name}
${this.#desc}

${Object.keys(this.#schemas).map(method => {
  const title = `## ${method}`;
  let params = '';
  let response = '';
  let body = '';
  let query = '';
  const schema = this.#schemas[method];
  let res;
  if(schema) {
    // console.log(this.#params);
    res = generate(schema, {context: {method}, mock: this});
  }
  if(this.#params[method]) {
    const _p = this.#params[method];
    if(method !== 'GET') {
      body = makeParamsBody(_p);
    } else {
      query = makeQuery(_p);
    }
    
    params = `
### Params

| name | type | description |
| --- | --- | --- |
|${_p.map(({name, type, info}) => [name, type, info].join('|')).join('\n')}|
`;
  }
  if(res) {
    const responseSeting = this.#responses[method];
    let responseInfo = '';
    if(responseSeting) {
      const _r = [];
      for(const [name, [type, info]] of Object.entries(responseSeting)) {
        _r.push({name, type, info});
      }
      responseInfo = `
| name | type | description |
| --- | --- | --- |
| ${_r.map(({name, type, info}) => [name, type, info].join('|')).join('\n')} |
`;
    }
    
    response = `
### Response

${responseInfo}

\`\`\`js
await (await fetch('$$service$$${query}', {
  method: '${method.toUpperCase()}',
  headers: {
    'Content-Type': 'application/json',
  }, ${body}
})).json();
\`\`\`

Will return the following data:

\`\`\`json
${JSON.stringify(res, null, 2)}
\`\`\`
`;
  }
  
  return `${title}
${params}
${response}
`;
}).join('\n\n')}
`;
  }

  param(method, {name, type, defaultValue, info}) {
    this.#params[method] = this.#params[method] || [];
    if(!this.#params[method].some(p => p.name === name)) {
      this.#params[method].push({name, type, info, defaultValue});
    }
  }

  compile() {
		return async (params, context) => {
      // console.log(process.env, params, context);
      const contentType = context.headers['content-type'];
      if(contentType !== 'application/json') {
        context.set('content-type', 'text/html');
        const markdownBody = marked.parse(this.info());
        return await display(path.join(__dirname, 'index.html'), {markdownBody});
      }
			const method = context.method;
			const headers = this.#responseHeaders[method];
			if(headers) {
				for(const [k, v] of Object.entries(headers)) {
					context.set(k, v);
				}
			}
			const schema = this.#schemas[method];
			if(schema) {
				return generate(schema, {params, context, mock: this});
			}
			if(typeof context.status === 'function') context.status(403);
      else if(context.response) context.response.status = 403;
			return {error: 'method not allowed'};
		};
  }

  execute(params, context) {
    return this.compile()(params, context);
  }

	use(schema, {headers = {}, response = null, allowMethods = ['GET','POST','PUT','DELETE']} = {}) {
		allowMethods.forEach((m) => {
			this.#schemas[m] = schema;
      this.#responseHeaders[m] = headers;
      this.#responses[m] = response;
		});
	}

	get(schema, options) {
		return this.use(schema, {...options, allowMethods: ['GET']});
	}

  post(schema, options) {
		return this.use(schema, {...options, allowMethods: ['POST']});
	}
	
  put(schema, options) {
		return this.use(schema, {...options, allowMethods: ['PUT']});
	}
	
  delete(schema, options) {
		return this.use(schema, {...options, allowMethods: ['DELETE']});
	}
};
